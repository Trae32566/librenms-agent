#!/usr/bin/env bash

# List of legacy SMART attribute fields - 9 is in main()
legacyIDs=(5 10 173 177 183 184 187 188 190 194 196 197 198 199 231 233)

# Get a list of detected devices from smartctl
scanResults="$(smartctl --scan-open -j)"
# Number of devices detected by smartctl
deviceCount="$(jq '.devices | length' <<< "${scanResults}")"

# Helper function to device information from jq
get_dev_info() { jq -r ".devices[${1}].\"${2}\"" <<< "${scanResults}"; }

get_smart() {
    unset multiDisk

    printf '{\n    "data": ['
    for ((device = 0; device < "${deviceCount:-0}" ; device++)); do
        # This doesn't work, scsi is not ata
        smartJSON="$(smartctl -j -a "$(get_dev_info "${device}" name)" -d "$(get_dev_info "${device}" type)")"
        smartRetCode="${?}"
        # Break out of the loop on failure unless it's due to unavailable SMART data (error code 4)
        [ "${smartRetCode}" -ne 0 ] && [ "${smartRetCode}" -ne 4 ] && break

        # Add a comma if there are multiple items in the list
        printf "${multiDisk:+,}${smartJSON}"
        multiDisk=true
    done

    cat << METADATA
],
    "error": $(jq '.smartctl.exit_status' <<< "${smartJSON}" 2>/dev/null),
    "errorString": $(jq '.smartctl.messages[0].string' <<< "${smartJSON}"  2>/dev/null || echo 'smartctl error string missing!'),
    "version": "1.0.0"
}
METADATA
}

main() {
    librenmsJSON="$(get_smart)"

   if ! which 'jq' > /dev/null 2>&1; then
        errorCode=1
        # The underscore here is a hack since we have to strip spaces without jq
        errorString='jq_missing!'
    elif [ "${1,,}" == '--json' ]; then
        # We don't care if this fails since it will always return the error in the JSON data
        jq -c '.' <<< "${librenmsJSON}"
    else
        # helper for grabbing legacy information - probably needs more code to provide null on non-error missing values
        get_legacy_info() {
            legacyInfo=$(jq -r ".data[${1}].${2}" <<< "${librenmsJSON}" 2>/dev/null || echo 'null')
            # If there is no data, return null
            sed -r 's/ \(.*\)//' <<< "${legacyInfo:-null}"
        }

        for ((legacyDevice = 0; legacyDevice < "${deviceCount:-0}" ; legacyDevice++)); do
            # Grab each attribute manually
            printf '%s,' "$(get_legacy_info "${legacyDevice}" serial_number)"
            for legacyID in "${legacyIDs[@]}"; do
                printf '%s,' "$(get_legacy_info "${legacyDevice}" "\"ata_smart_attributes\".table[] | select(.id==${legacyID}).raw.string")"
            done

            # Analogous to $completed in legacy perl script - this is WRONG
            printf '%s,' "$(get_legacy_info "${legacyDevice}" '"ata_smart_data".selftest.status.value')"
            # MISSING: completed interrupted read_failure unknown_failure
            printf '0,0,0,0,'
            # TODO: Get extended self-test status
            printf '%s,' "$(get_legacy_info "${legacyDevice}" '"ata_smart_data".selftest.status.value')"
            # TODO: Get short self-test status
            printf '%s,' "$(get_legacy_info "${legacyDevice}" '"ata_smart_data".selftest.status.value')"
            # MISSING: conveyance selective
            printf '0,0,'
            # Get SMART attribute 9 since it's last in the legacy format
            printf '%s' "$(get_legacy_info "${legacyDevice}" '"ata_smart_attributes".table[] | select(.id==9).value')"
            echo
        done
    fi

}

main "${@}"
